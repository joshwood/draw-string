<!DOCTYPE html>
<html>
<head>
    <title></title>
    <script src="thirdParty/js/fabric-1.4.0.min.js"></script>
    <script src="thirdParty/js/jquery-1.9.1.min.js"></script>

    <style>
        body {
            margin: 0;
            padding: 0
        }
        #c{
            border-style: solid;
        }
        .canvas-container{
            margin-bottom: 10px;
        }
        #controls input{
            display: inline;
        }
        .layer-controls{
            text-decoration: none;
        }
    </style>
    <link href="resources/css/main.css" rel="stylesheet" type="text/css" />

</head>
<body>

    <div id="controls">
        <label for="drawingMode">Draw</label>
        <select id="drawingMode">
            <option value="">Off</option>
            <option value="rectangle">Rectangle</option>
            <option value="line">Line</option>
            <option value="free">Free Draw</option>
        </select>
        <input type="button" id="drawSquares" value="2 Squares"/>
        <div>
            Object layer position
        <br/>
        <a href="#" id="sendToBack" class="layer-controls"><img src="resources/images/arrow-first.gif"></a>
        <a href="#" id="sendBackwards" class="layer-controls"><img src="resources/images/arrow-previous.gif"></a>
        <a href="#" id="bringForward" class="layer-controls"><img src="resources/images/arrow-next.gif"></a>
        <a href="#" id="bringToFront" class="layer-controls"><img src="resources/images/arrow-last.gif" alt="Bring to Front"></a>
        </div>
    </div>
    <canvas id="c"></canvas>
    <div id="colorholder">
        <div class="colorbox" style="background-color: white"></div>
        <div class="colorbox" style="background-color: black"></div>
        <div class="colorbox" style="background-color: red"></div>
        <div class="colorbox" style="background-color: green"></div>
        <div class="colorbox" style="background-color: blue"></div>
        <div class="colorbox" style="background-color: deepskyblue"></div>
        <div class="colorbox" style="background-color: yellow"></div>
        <div class="colorbox" style="background-color: chartreuse"></div>
    </div>
    <div>
        <span>Current Color: </span><div class="colorbox" id="currentColorBox"></div>
    </div>

    <script type="text/javascript">document.write('<script src="http://'
            + (location.host || 'localhost').split(':')[0]
            + ':3000/socket.io/socket.io.js" type="text/javascript"><\/script>')
    </script>
    <script>
/*
 need to look at this
 http://stackoverflow.com/questions/20824019/fabric-js-get-objects-by-name
 */
        (function() {

            var socket = io.connect("http://"+window.location.hostname+":3000");

            var c = new fabric.Canvas('c', {selection: false});

            c.setHeight(400);
            c.setWidth(500);
            c.isDrawingMode = false;

            var line, rectangle, mouseDown;
            var startX, startY;

            c.on("mouse:down", function(o){
                mouseDown = true;

                // http://jsfiddle.net/URWru/
                if($('#drawingMode').val() === 'line'){
                    var pointer = c.getPointer(o.e);
                    var points = [ pointer.x, pointer.y, pointer.x, pointer.y ];
                    line = new fabric.Line(points, {
                        strokeWidth: 1,
                        strokeDashArray: [5, 3],
                        stroke: currentColor,
                        fill: '',
                        originX: 'center',
                        originY: 'center'
                    });
                    c.add(line);
                }

                if($('#drawingMode').val() === 'rectangle'){
                    var pointer = c.getPointer(o.e);
                    rectangle = new fabric.Rect({
                        strokeWidth: 1,
                        strokeDashArray: [5, 3],
                        stroke: currentColor,
                        fill: '',
                        top: pointer.y,
                        left: pointer.x,
                        originY: 'top',
                        originX: 'left'
                    });
                    c.add(rectangle);
                }

                startX = o.e.offsetX;
                startY = o.e.offsetY;
            });

            c.on("mouse:move", function(o){
                if(!mouseDown) return;
                if($('#drawingMode').val() === 'line'){
                    var pointer = c.getPointer(o.e);
                    line.set({ x2: pointer.x, y2: pointer.y });
                    c.renderAll();
                }
                if($('#drawingMode').val() === 'rectangle'){
                    var pointer = c.getPointer(o.e);

                    var width = pointer.x - rectangle.left;
                    var height = pointer.y - rectangle.top;

                    rectangle.width = width;
                    rectangle.height = height;
                    c.renderAll();
                }
            });

            c.on("mouse:up", function(o){
                mouseDown = false;
                if($('#drawingMode').val() === 'line'){
                    c.remove(line);
                    drawLine(line.x1, line.y1, line.x2, line.y2, currentColor, 6, currentColor);
                }
                if($('#drawingMode').val() === 'rectangle'){
                    c.remove(rectangle);
                    drawRectangle(rectangle.left, rectangle.top, rectangle.width, rectangle.height, currentColor);
                }

                $('#drawingMode').val('');
            });

            c.on("object:modified", function(){
                console.log("modified");
            });

            c.on("object:selected", function(e){
                console.log("selected");
            });

            c.on("object:moving", function(e){
                socket.emit('changing', e.target);
            });

            c.on("object:scaling", function(e){
                //console.log("scaling");
                socket.emit('changing', e.target);
            });

            c.on("object:rotating", function(e){
                console.log("rotating");
                socket.emit('changing', e.target);
            });

            c.on("object:added", function(e){
                console.log("added "+ e.target.type);
            });

            c.on("object:removed", function(){
                console.log("removed");
            });

            c.on("selection:cleared", function(e){
                console.log("selection cleared ");
            });

            $('#drawingMode').on('change', function(e){
                c.isDrawingMode = this.value === "free";
            });

            $('#sendToBack').on('click', function(e){
                if(c.getActiveObject()){
                    socket.emit('sendToBack', c.getActiveObject());
                }
                return false;
            });
            $('#sendBackwards').on('click', function(e){
                if(c.getActiveObject()){
                    socket.emit('sendBackwards', c.getActiveObject());
                }
                return false;
            });
            $('#bringForward').on('click', function(e){
                if(c.getActiveObject()){
                    socket.emit('bringForward', c.getActiveObject());
                }
                return false;
            });
            $('#bringToFront').on('click', function(e){
                if(c.getActiveObject()){
                    socket.emit('bringToFront', c.getActiveObject());
                }
                return false;
            });

            $('#drawSquares').on('click', function(e){
                drawRectangle(50, 50, 50, 50, currentColor);
                drawRectangle(150, 150, 50, 50, currentColor);
            });

            function drawRectangle(x, y, width, height, fill){
                // create a rectangle object
                var rect = new LabeledRect({
                    left: x,
                    top: y,
                    originX: 'left',
                    originY: 'top',
                    fill: fill,
                    width: width,
                    height: height,
                    fill: fill
                });
                socket.emit('addObject', rect);
            }

            function drawLine(x1, y1, x2, y2, stroke, strokeWidth, fill){
                var newLine = new LabeledLine([x1, y1, x2, y2], {
                    strokeWidth: strokeWidth,
                    fill: fill,
                    stroke: stroke,
                    originX: 'center',
                    originY: 'center'
                });
                socket.emit('addObject', newLine);
            }

            socket.on('addObject', function(o){
                if(o.type === 'labeledRect'){
                    c.add(new LabeledRect(o));
                }else if(o.type === 'labeledLine') {
                    c.add(new LabeledLine([o.x1, o.y1, o.x2, o.y2], o));
                }
            });

            socket.on('changing', function(o){

                $(c.getObjects()).each(function(){
                    if(this._id === o._id){
                        // we must set to active every time, seems odd but only way to make it "real time" react
                        c.setActiveObject(this);
                        // this is pretty lame, i'm just transfering everything, surely a better way
                        this.angle = o.angle;
                        this.backgroundColor = o.backgroundColor;
                        this.clipTo = o.clipTo;
                        this.fill = o.fill;
                        this.flipX = o.flipX;
                        this.flipY = o.flipY;
                        this.height = o.height;
                        this.left = o.left;
                        this.opacity = o.opacity;
                        this.originX = o.originX;
                        this.originY = o.originY;
                        this.rx = o.rx;
                        this.ry = o.ry;
                        this.scaleX = o.scaleX;
                        this.scaleY = o.scaleY;
                        this.shadow = o.shadow;
                        this.stroke = o.stroke;
                        this.strokeDashArray = o.strokeDashArray;
                        this.strokeLineCap = o.strokeLineCap;
                        this.strokeLineJoin = o.strokeLineJoin;
                        this.strokeMiterLimit = o.strokeMiterLimit;
                        this.strokeWidth = o.strokeWidth;
                        this.top = o.top;
                        this.visible = o.visible;
                        this.width = o.width;
                        this.x = o.x;
                        this.y = o.y;
                        this.setCoords();
                    }
                });
            });

            socket.on('sendToBack', function(o){
                $(c.getObjects()).each(function(){
                    if(this._id === o._id){
                        // we must set to active every time, seems odd but only way to make it "real time" react
                        c.setActiveObject(this);
                        var before = c.getObjects().indexOf(this);
                        this.sendToBack();
                        var after = c.getObjects().indexOf(this);
                        console.log("INDEX "+before+ " : "+after);
                    }
                });
            });

            socket.on('sendBackwards', function(o){
                $(c.getObjects()).each(function(){
                    if(this._id === o._id){
                        // we must set to active every time, seems odd but only way to make it "real time" react
                        c.setActiveObject(this);
                        this.sendBackwards();
                    }
                });
            });
            socket.on('bringForward', function(o){
                $(c.getObjects()).each(function(){
                    if(this._id === o._id){
                        // we must set to active every time, seems odd but only way to make it "real time" react
                        c.setActiveObject(this);
                        this.bringForward();
                    }
                });
            });
            socket.on('bringToFront', function(o){
                $(c.getObjects()).each(function(){
                    if(this._id === o._id){
                        // we must set to active every time, seems odd but only way to make it "real time" react
                        c.setActiveObject(this);
                        this.bringToFront();
                    }
                });
            });


            /*
             * http://www.sitepoint.com/fabric-js-advanced/
             */
            var LabeledRect = fabric.util.createClass(fabric.Rect, {
                type: 'labeledRect',
                initialize: function(options) {
                    options || (options = { });
                    this.callSuper('initialize', options);
                    this.set('_id', options._id);
                },
                toObject: function() {
                    return fabric.util.object.extend(this.callSuper('toObject'), {
                        _id: this.get('_id')
                    });
                }
            });

            var LabeledLine = fabric.util.createClass(fabric.Line, {
                type: 'labeledLine',
                initialize: function(points, options) {
                    options || (options = { });
                    points || (points = []);
                    this.callSuper('initialize', points, options);
                    this.set('_id', options._id);
                },
                toObject: function() {
                    return fabric.util.object.extend(this.callSuper('toObject'), {
                        _id: this.get('_id')
                    });
                }
            });

            /*
             * handles click event on the color selector
             */
            var currentColor = 'red';
            $(".colorbox").click(function(){

                currentColor = $(this).css('background-color');

                $('#currentColorBox').css('background-color', currentColor);

                if(c.getActiveObject()){
                    c.getActiveObject().fill = currentColor;
                    c.getActiveObject().stroke = currentColor;
                    c.getActiveObject().setCoords();
                    // this is lame, for some reason when changing colors, clients dont' update
                    // we send 2 messages and it updates
                    socket.emit('changing', c.getActiveObject());
                    socket.emit('changing', c.getActiveObject());
                }
            });

            $('#currentColorBox').css('background-color', currentColor);

        })();


    </script>

</body>
</html>