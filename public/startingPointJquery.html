<html>
<head>
    <title>Start Drawing</title>

    <script src="thirdParty/js/jquery-1.9.1.min.js"></script>

    <script src="http://localhost:3000/socket.io/socket.io.js"></script>

    <link href="resources/css/main.css" rel="stylesheet" type="text/css" />
</head>
<body style="text-align: center">
<h1>Start Drawing</h1>
<div style="padding-bottom: 20px;">
    <span>Try opening another browser at this same URL and draw on either canvas to see the web sockets in action.</span>
</div>
<div>
    <canvas id="drawing-canvas" width="480" height="420"></canvas>
</div>
<div id="colorholder"></div>
<script>
    $(document).ready(function () {

        /*
         * I completely ripped this off from a firebase example and substituted node/websockets
         * http://runnable.com/UnA1wDlk6cVmAAAr/firebase-collaborative-drawing-example-for-javascript
         * http://coenraets.org/blog/2012/10/real-time-web-analytics-with-node-js-and-socket-io/
         */


        /*
         * this will eventually be a unique id generated by some process.
         * we use this to allow multiple drawings
         */
        var drawingId = "YADA";
        var coordinatesResource = drawingId;
        var socketURL = 'http://localhost:3000?drawingId='+drawingId;

        /*
         * here we make the connection to the websocket
         */
        var socket = io.connect(socketURL);
        socket.on('connect', function () {
            console.log("Connected to server");
        });

        //Set up some globals
        var pixSize = 1, lastPoint = null, currentColor = "000", mouseDown = 0;

        // Set up our canvas
        var myCanvas = document.getElementById('drawing-canvas');
        var myContext = myCanvas.getContext ? myCanvas.getContext('2d') : null;
        if (myContext == null) {
            alert("You must use a browser that supports HTML5 Canvas to run this demo.");
            return;
        }

        //Setup each color palette & add it to the screen
        var colors = ["fff","000","f00","0f0","00f","88f","f8d","f88","f05","f80","0f8","cf0","08f","408","ff8","8ff"];
        for (c in colors) {
            var item = $('<div/>').css("background-color", '#' + colors[c]).addClass("colorbox");
            item.click((function () {
                var col = colors[c];
                return function () {
                    currentColor = col;
                };
            })());
            item.appendTo('#colorholder');
        }

        //Keep track of if the mouse is up or down
        myCanvas.onmousedown = function () {mouseDown = 1;};
        myCanvas.onmouseout = myCanvas.onmouseup = function () {
            mouseDown = 0, lastPoint = null;
        };

        //Draw a line from the mouse's last position to its current position
        var drawLineOnMouseMove = function(e) {
            if (!mouseDown) return;

            // Bresenham's line algorithm. We use this to ensure smooth lines are drawn
            var offset = $('canvas').offset();
            var x1 = Math.floor((e.pageX - offset.left) / pixSize - 1),
                    y1 = Math.floor((e.pageY - offset.top) / pixSize - 1);
            var x0 = (lastPoint == null) ? x1 : lastPoint[0];
            var y0 = (lastPoint == null) ? y1 : lastPoint[1];
            var dx = Math.abs(x1 - x0), dy = Math.abs(y1 - y0);
            var sx = (x0 < x1) ? 1 : -1, sy = (y0 < y1) ? 1 : -1, err = dx - dy;
            while (true) {

                //write the pixel to the server
                socket.emit('coordinates', {'drawingId':drawingId, 'x': x0, 'y': y0, 'color': currentColor, 'pixelSize': pixSize});

                if (x0 == x1 && y0 == y1) break;
                var e2 = 2 * err;
                if (e2 > -dy) {
                    err = err - dy;
                    x0 = x0 + sx;
                }
                if (e2 < dx) {
                    err = err + dx;
                    y0 = y0 + sy;
                }
            }
            lastPoint = [x1, y1];
        }
        $(myCanvas).mousemove(drawLineOnMouseMove);
        $(myCanvas).mousedown(drawLineOnMouseMove);

        // Add callbacks that are fired any time the pixel data changes and adjusts the canvas appropriately.
        // Note that child_added events will be fired for initial pixel data as well.
        var drawPixel = function(point) {
            myContext.fillStyle = "#" + point.color;
            myContext.fillRect(parseInt(point.x) * pixSize, parseInt(point.y) * pixSize, pixSize, pixSize);
        }

        /*
         * here we listen for any messages and update our screen
         */
        socket.on(coordinatesResource, drawPixel);

        /*
         * here we run out an grab any coordinates we may already have for this drawing
         */
        $.getJSON('drawings/'+drawingId+"/coordinates", function(data){
            $.each(data, function(i, item){
                drawPixel(item);
            });
        });

    });
</script>
</body>
</html>
